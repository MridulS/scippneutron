#import "@preview/physica:0.9.3": *

#set math.equation(numbering: "(1)")
#show link: underline

= Approximation for computing L2 with gravity in SANS

The neutron travels along curve
$
    C: arrow(c)(t) = vec(v_x t, -g/2 t^2 + v_y t, v_z t) .
$
with initial velocity
$
    arrow(v) = v vec(cos(phi) sin(2 theta), sin(phi) sin(2 theta), cos(2 theta)),
    quad
    v = h/(m_n lambda) .
$

For a detector located at $z_d = v_z t_d$, this means that the neutron is detected at
$
    arrow(p) = vec(x_d, y_d, z_d) = vec(v_x t_d, -g/2 t_d^2 + v_y t_d, v_z t_d)
$
To determine the scattering angles, we can consider the point where
the neutron would be detected without gravity:
$
    arrow(p)" = vec(x_d, y"_d, z_d) = vec(v_x t_d, v_y t_d, v_z t_d) = v t_d vec(cos(phi) sin(2 theta), sin(phi) sin(2 theta), cos(2 theta))
$
Thus
$
    tan(2 theta) = sqrt(x_d^2 + y"_d^2) / z_d,
    quad
    y"_d = y_d + g/2 t_d^2 = y_d + (g m_n^2 lambda^2) / (2 h^2) L"_2^2
$<tan_two_theta>
with
$
    L"_2^2 = z_d^2 / cos(2 theta)^2
$

Solving these equations for $2 theta$ is difficult.
However, the impact of gravity is small, *so we approximate*
#footnote[Mantid uses the same approximation. See #link("https://docs.mantidproject.org/nightly/algorithms/Q1D-v2.html#q-unit-conversion")]
$L_2 approx L"_2$.
And $L_2 = abs(arrow(p))$ is readily available from pixel positions.

== Validity of the approximation.

We found evidence that the approximation has an unexpectedly large impact on the end result ($I(Q)$).
This was observed by using $sin(2 theta) = sqrt(x^2 + y"^2) / L_2$.
This equation is also an approximation.
But it would be exact if it used $L"_2$ in the denominator instead of $L_2$.

With SANS2D data, we found a relative difference of $~10^(-5)$ in the resulting $2 theta$.
This amounted to a relative difference of $~10^(-4)$ in $I(Q)$ which is within statistical uncertainties.
However, LOKI is rather long and allows for measuring relatively large angles.
So it is a priori not clear that the approximation holds.

To test it, we
+ Pick a set of values of $lambda$, $z_d$, $2 theta$, $phi$.
+ Compute $arrow(p)$ from those.
+ Compute $2 theta$ using $arrow(p)$ and @tan_two_theta.

The figure generated by the code below shows the relative difference $("true_two_theta" - "approx_two_theta") / "true_two_theta"$ for $phi = 90 degree$.
Parameters were chosen in realistic ranges for LOKI.
The error of the approximation is no larger than $~10^(-6)$.
So the impact on the final $I(Q)$ will likely be within statistical uncertainties and can be neglected.

```python
import matplotlib.pyplot as plt
import scipp as sc
import scipp.constants


def two_theta_approx(
    *,
    wavelength,
    two_theta,
    phi,
    z_det,
):
    v = sc.constants.h / sc.constants.m_n / wavelength
    v_x = v * sc.cos(phi) * sc.sin(two_theta)
    v_y = v * sc.sin(phi) * sc.sin(two_theta)

    t_det = z_det / (v * sc.cos(two_theta))
    x_det = v_x * t_det
    y_det = v_y * t_det
    y_det = y_det - (sc.constants.g * t_det**2 / 2).to(unit=y_det.unit)

    L2 = sc.sqrt(x_det**2 + y_det**2 + z_det**2)
    drop = (
        sc.constants.g
        / 2
        * sc.constants.m_n**2
        * wavelength**2
        / sc.constants.h**2
        * L2**2
    )
    y_det_prime = y_det + drop.to(unit=y_det.unit)

    return sc.atan2(y=sc.sqrt(x_det**2 + y_det_prime**2), x=z_det)


def main() -> None:
    wavelength = sc.linspace("wavelength", 0.1, 20.0, 6, unit="Ã…")
    two_theta = sc.linspace("two_theta", 0.0, 50.0, 50, unit="deg").to(unit="rad")
    phi = sc.scalar(90.0, unit="deg").to(unit="rad")
    z_det = sc.linspace("z_det", 1.0, 10.0, 50, unit="m")

    approx = two_theta_approx(
        wavelength=wavelength, two_theta=two_theta, phi=phi, z_det=z_det
    )
    error = (two_theta - approx) / two_theta
    error = sc.DataArray(
        error,
        coords={"two_theta": two_theta, "z_det": z_det, "phi": phi, "wavelength": wavelength},
    )

    fig, axs = plt.subplots(2, 3)
    for i, ax in zip(range(error.sizes["wavelength"]), axs.flat, strict=True):
        da = error["wavelength", i]
        da.plot(ax=ax)
        ax.set_title(f"wavelength={da.coords["wavelength"]:c}")
    plt.show()


if __name__ == "__main__":
    main()
```
